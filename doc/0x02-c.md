# C Programming Language Cheat Sheet

<img src="../img/cLang/cLang.jpeg">

## üìå Basic Data Types

| Type            | Size    | Range                           | Description        |
| --------------- | ------- | ------------------------------- | ------------------ |
| `char`          | 1 byte  | -128 to 127                     | Single character   |
| `unsigned char` | 1 byte  | 0 to 255                        | Unsigned character |
| `short int`     | 2 bytes | -32,768 to 32,767               | Short integer      |
| `int`           | 4 bytes | -2,147,483,648 to 2,147,483,647 | Standard integer   |
| `long long int` | 8 bytes | Very large range                | Long integer       |
| `float`         | 4 bytes | \~6-7 decimal digits            | Single precision   |
| `double`        | 8 bytes | \~15-17 decimal digits          | Double precision   |

### üìè Size Check Example

```c
printf("%d\n", sizeof(int));
```

### üìö Limits with `<limits.h>`

To retrieve implementation-specific limits for integral types, include the `<limits.h>` header.

```c
#include <limits.h>
```

#### üîë Common Limits from `<limits.h>`

| Macro        | Description                       | Example Value             |
| ------------ | --------------------------------- | ------------------------- |
| `CHAR_BIT`   | Number of bits in a `char`        | 8                         |
| `CHAR_MIN`   | Minimum value of `char`           | -128                      |
| `CHAR_MAX`   | Maximum value of `char`           | 127                       |
| `INT_MIN`    | Minimum value of `int`            | -2,147,483,648            |
| `INT_MAX`    | Maximum value of `int`            | 2,147,483,647             |
| `UINT_MAX`   | Maximum value of `unsigned int`   | 4,294,967,295             |
| `LONG_MIN`   | Minimum value of `long`           | Typically ‚àí2,147,483,648  |
| `LONG_MAX`   | Maximum value of `long`           | Typically 2,147,483,647   |
| `ULONG_MAX`  | Max value of `unsigned long`      | 4,294,967,295 or higher   |
| `LLONG_MIN`  | Minimum value of `long long`      | Very large negative value |
| `LLONG_MAX`  | Maximum value of `long long`      | Very large positive value |
| `ULLONG_MAX` | Max value of `unsigned long long` | Max unsigned 64-bit value |

Use these constants to write portable, safe programs across different systems.

## üìÇ System Types: `<sys/types.h>`

The `<sys/types.h>` header defines data types used in system-level programming, especially for POSIX-compliant operating systems (like Linux). These types are typically used for file descriptors, process IDs, sizes, and more.

```c
#include <sys/types.h>
```

### üìå Common Types in `<sys/types.h>`

| Type        | Description                                             |
| ----------- | ------------------------------------------------------- |
| `pid_t`     | Process ID                                              |
| `uid_t`     | User ID                                                 |
| `gid_t`     | Group ID                                                |
| `off_t`     | File size or offset (used with `lseek`, `stat`, etc.)   |
| `mode_t`    | File permission/mode bits                               |
| `size_t`    | Unsigned size type (also from `<stddef.h>`)             |
| `ssize_t`   | Signed size type (used for return values, e.g., `read`) |
| `time_t`    | Time value (used with `time()`, `ctime()`, etc.)        |
| `dev_t`     | Device ID (used with `stat()`)                          |
| `ino_t`     | Inode number                                            |
| `nlink_t`   | Number of hard links                                    |
| `blksize_t` | Block size                                              |
| `blkcnt_t`  | Number of blocks                                        |

> These types improve portability and ensure consistency when interfacing with system calls or low-level I/O.

## üéØ Program Entry Point

### Basic Program Structure

```c
#include <stdio.h>

int main() {
    printf("Hello, World!\n");
    return 0;
}
```

### Full main() Function Signature

```c
int main(int argc, char** argv, char** envp)
```

- **argc** - argument count
- **argv** - argument values (array of strings)
- **envp** - environment variables (array of strings)

### Command Line Arguments Example

```c
#include <stdio.h>

int main(int argc, char** argv) {
    printf("Number of arguments: %d\n", argc);
    for (int i = 0; i < argc; i++) {
        printf("argv[%d]: %s\n", i, argv[i]);
    }
    return 0;
}
```

## üîó Pointers

### Declaration and Usage

```c
int *ptr;                    // Declare pointer
ptr = (int*)malloc(sizeof(int)); // Allocate memory
*ptr = 42;                   // Set value
printf("Value: %d\n", *ptr); // Access value
free(ptr);                   // Free memory
```

### Pointer Operators

| Operator | Description | Example     |
| -------- | ----------- | ----------- |
| `&`      | Address-of  | `&variable` |
| `*`      | Dereference | `*pointer`  |

## üì•üì§ Input/Output Functions

### Format Specifiers

| Specifier | Type         | Description            |
| --------- | ------------ | ---------------------- |
| `%d`      | int          | Decimal integer        |
| `%i`      | int          | Integer (detects base) |
| `%u`      | unsigned     | Unsigned decimal       |
| `%x`      | int          | Hexadecimal            |
| `%o`      | int          | Octal                  |
| `%c`      | char         | Single character       |
| `%s`      | char\*       | String                 |
| `%f`      | float/double | Floating point         |
| `%.2f`    | float/double | 2 decimal places       |
| `%02d`    | int          | Zero-padded integer    |

### Standard I/O

```c
// Reading input
int num;
char str[100];
scanf("%d", &num);           // Read integer
scanf("%s", str);            // Read string (no spaces)
gets(str);                   // Read line (deprecated - unsafe)

// Writing output
printf("Number: %d\n", num);
puts(str);                   // Print string with newline
```

### File I/O

```c
#include <stdio.h>

// Writing to file
FILE *file = fopen("output.txt", "w");
if (file != NULL) {
    fprintf(file, "Hello, file!\n");
    fclose(file);
}

// Reading from file
FILE *file = fopen("input.txt", "r");
if (file != NULL) {
    char buffer[100];
    if (fscanf(file, "%s", buffer) == 1) {
        printf("Read: %s\n", buffer);
    }
    fclose(file);
}
```

### File Modes

| Mode   | Description                 |
| ------ | --------------------------- |
| `"r"`  | Read only                   |
| `"w"`  | Write only (overwrites)     |
| `"a"`  | Append only                 |
| `"r+"` | Read and write              |
| `"w+"` | Read and write (overwrites) |

## üßæ `puts` vs `printf`, `gets` vs `scanf`, `f*` Functions

### üì§ Output

| Function    | Description                            |
| ----------- | -------------------------------------- |
| `puts()`    | Prints a string + newline              |
| `printf()`  | Prints formatted output                |
| `fputs()`   | Like `puts`, but to a stream (no `\n`) |
| `fprintf()` | Like `printf`, but to a stream         |

### üì• Input

| Function   | Description                          |
| ---------- | ------------------------------------ |
| `gets()`   | ‚ö†Ô∏è Unsafe. Reads line, no size check |
| `fgets()`  | ‚úÖ Safe. Reads line with size limit  |
| `scanf()`  | Reads formatted input                |
| `fscanf()` | Like `scanf`, but from a file/stream |

### üí° Note

- Functions with prefix `f` (e.g. `fputs`, `fprintf`, `fscanf`) allow **working with any stream**, not just standard input/output.
- Use `f*()` when reading/writing to files (`FILE *f = fopen(...)`).
- Prefer `fgets()` over `gets()` for safety.

## üñ•Ô∏è System Calls

### Common System Calls

```c
#include <fcntl.h>  // POSIX header file for open()
#include <unistd.h>

// File operations
int fd = open("file.txt", O_RDONLY);  // Open file
char buffer[100];
ssize_t bytes = read(fd, buffer, 99); // Read data
write(fd, "data", 4);                 // Write data
close(fd);                            // Close file

// Standard file descriptors
// STDIN_FILENO  (0) - Standard input
// STDOUT_FILENO (1) - Standard output
// STDERR_FILENO (2) - Standard error
```

### System Call vs Library Function

| System Call | Library Function        |
| ----------- | ----------------------- |
| `open()`    | `fopen()`               |
| `read()`    | `fread()`, `fscanf()`   |
| `write()`   | `fwrite()`, `fprintf()` |
| `close()`   | `fclose()`              |

> üìñ Full list of syscall numbers:
> [https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md#x86-32_bit](https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md#x86-32_bit)

## üî§ String Manipulation in C

### üìö String Library (`<string.h>`)

To work with strings in C, you use functions provided by the standard **`<string.h>`** library:

```c
#include <string.h>

char str1[50] = "Hello";
char str2[] = "World";
char dest[100];
```

### üîß Common String Functions

| Function                   | Description                                                               |
| -------------------------- | ------------------------------------------------------------------------- |
| `strlen(s)`                | Returns the length of string `s` (excluding the null terminator).         |
| `strcpy(dest, src)`        | Copies the string `src` into `dest`.                                      |
| `strncpy(dest, src, n)`    | Copies up to `n` characters from `src` to `dest`.                         |
| `strcat(dest, src)`        | Appends string `src` to the end of `dest`.                                |
| `strncat(dest, src, n)`    | Appends up to `n` characters from `src` to `dest`.                        |
| `strcmp(s1, s2)`           | Compares `s1` and `s2` lexicographically.                                 |
| `strncmp(s1, s2, n)`       | Compares up to `n` characters of `s1` and `s2`.                           |
| `strchr(s, c)`             | Returns a pointer to the first occurrence of character `c` in string `s`. |
| `strrchr(s, c)`            | Returns a pointer to the last occurrence of character `c` in string `s`.  |
| `strstr(haystack, needle)` | Returns a pointer to the first occurrence of substring `needle`.          |
| `strtok(s, delim)`         | **Splits a string into tokens** using specified delimiters.               |

---

### üîç String Tokenization with `strtok`

The `strtok()` function is used to split a string into **tokens** (substrings), based on a set of delimiter characters.

#### ‚úÖ Example

```c
#include <stdio.h>
#include <string.h>

int main() {
    char text[] = "apple,banana,orange";
    char *token = strtok(text, ",");   // First call with the input string

    while (token != NULL) {
        printf("Token: %s\n", token);
        token = strtok(NULL, ",");     // Subsequent calls with NULL
    }

    return 0;
}
```

#### ‚öôÔ∏è How `strtok` Works

- **First call:** `strtok(original_string, delimiters)` ‚Äî returns the first token.
- **Subsequent calls:** `strtok(NULL, delimiters)` ‚Äî continues from where it left off.
- Replaces each delimiter with `\0` to separate the tokens.
- Modifies the original string (not safe for read-only strings).

#### ‚ö†Ô∏è Limitations

- **Not thread-safe**: It uses internal static state.
- Use `strtok_r()` in multithreaded environments (POSIX-compliant systems).

---

### üß™ String Comparison Results

| `strcmp()` Result | Meaning                      |
| ----------------- | ---------------------------- |
| `0`               | Strings are equal            |
| `< 0`             | First string < Second string |
| `> 0`             | First string > Second string |

## üî¢ Bitwise Operations

### Bitwise Operators

| Operator | Name        | Example  | Description             |
| -------- | ----------- | -------- | ----------------------- |
| `\|`     | OR          | `x \| y` | Bitwise OR              |
| `&`      | AND         | `x & y`  | Bitwise AND             |
| `^`      | XOR         | `x ^ y`  | Bitwise XOR             |
| `~`      | NOT         | `~x`     | Bitwise NOT             |
| `<<`     | Left Shift  | `x << n` | Shift left n positions  |
| `>>`     | Right Shift | `x >> n` | Shift right n positions |

### Truth Table

| x   | y   | x\|y | x&y | x^y |
| --- | --- | ---- | --- | --- |
| 0   | 0   | 0    | 0   | 0   |
| 0   | 1   | 1    | 0   | 1   |
| 1   | 0   | 1    | 0   | 1   |
| 1   | 1   | 1    | 1   | 0   |

### Shift Operations

```c
int x = 8;        // Binary: 1000
int left = x << 1;  // 16 (multiply by 2)
int right = x >> 1; // 4  (divide by 2)
```

## üîÑ Parameter Passing

### Pass by Value

```c
void modify_value(int x) {
    x = 100;  // Only changes local copy
}
```

### Pass by Reference (using pointers)

```c
void modify_reference(int *x) {
    *x = 100;  // Changes original value
}
```

### Arrays (implicitly passed by reference)

```c
void modify_array(int arr[], int size) {
    arr[0] = 999;  // Changes original array
}
```

## üîß GCC Compilation

```bash
# Basic compilation
gcc program.c -o program

# With debugging info
gcc -g program.c -o program

# With all warnings
gcc -Wall program.c -o program

# 32-bit compilation
gcc -m32 program.c -o program
```

## üìö Essential Headers

| Header     | Purpose           | Key Functions                      |
| ---------- | ----------------- | ---------------------------------- |
| `stdio.h`  | Standard I/O      | `printf()`, `scanf()`, `fopen()`   |
| `stdlib.h` | General utilities | `malloc()`, `free()`, `exit()`     |
| `string.h` | String operations | `strlen()`, `strcpy()`, `strcmp()` |
| `math.h`   | Math functions    | `sqrt()`, `pow()`, `sin()`         |
| `ctype.h`  | Character testing | `isdigit()`, `isalpha()`           |
| `time.h`   | Date and time     | `time()`, `clock()`                |
| `unistd.h` | UNIX standard     | `read()`, `write()`, `close()`     |
| `fcntl.h`  | File control      | `open()`, file flags               |

## üéØ Error Handling

```c
#include <errno.h>
#include <string.h>

FILE *file = fopen("nonexistent.txt", "r");
if (file == NULL) {
    fprintf(stderr, "Error: %s\n", strerror(errno));
    return 1;
}
```

## üî¢ Exit Codes

| Code  | Meaning                        |
| ----- | ------------------------------ |
| `0`   | Success                        |
| `1`   | General error                  |
| `2`   | Misuse of shell command        |
| `126` | Command invoked cannot execute |
| `127` | Command not found              |

### Using Exit Codes

```c
#include <stdlib.h>

int main() {
    if (/* error condition */) {
        exit(EXIT_FAILURE);  // or exit(1)
    }

    return EXIT_SUCCESS;     // or return 0
}
```

## üìö Headers (`.h`)

> Headers contain **declarations** of functions, variables, macros, and types.

### üîó Including Headers

| Syntax              | Description                                                                              |
| :------------------ | :--------------------------------------------------------------------------------------- |
| `#include <file.h>` | Searches in the **standard include directories** (system paths defined by the compiler). |
| `#include "file.h"` | Searches in the **current directory** first, then typically in standard directories.     |

## ‚öôÔ∏è Macros (`#define`, `#undef`)

Macros are simple text substitutions performed by the C **preprocessor** _before_ the compiler sees the code. They are defined using the `#define` directive.

#### üìù Object-like Macros (Constants)

Used to define constants, offering a type-agnostic alternative to `const` variables, though `const` variables are generally safer.

```c
#define MAX_SIZE 100
#define PI 3.14159265
#define DEBUG_MODE
```

#### üõ°Ô∏è Header Guards (Include Guards)

The most crucial use of preprocessor directives is preventing the contents of a header file from being included multiple times in a single translation unit, which would lead to redefinition errors.

```c
// Meaningful Snippet: Header Guard Structure
#ifndef MY_HEADER_H
#define MY_HEADER_H

// Declarations (functions, structs, etc.) go here

#endif // MY_HEADER_H
```

---

## üîÑ Type Casting

**Type casting** is a way to explicitly convert a value from one data type to another. It tells the compiler to treat a variable or expression of type $A$ as if it were of type $B$.

### üí° Basic (Explicit) Type Casting

The syntax for a cast is simply prefixing the expression with the desired type in parentheses.

```c
// Meaningful Snippet: Basic Type Cast
int total = 100;
int count = 7;

// Implicit division: Integer division discards the fractional part
float average_implicit = total / count; // average_implicit will be 14.00

// Explicit casting ensures floating-point division
float average_explicit = (float)total / count; // average_explicit will be 14.2857...
```

### üìè Size and Signedness Conversions

| Conversion Type     | Description                                                              | Effect                                                                                                                                                                |
| :------------------ | :----------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Widening**        | Converting from a smaller type to a larger type (e.g., `int` to `long`). | Generally safe, preserves the value.                                                                                                                                  |
| **Narrowing**       | Converting from a larger type to a smaller type (e.g., `long` to `int`). | **Dangerous**; can lead to **truncation** (loss of most-significant bits).                                                                                            |
| **Signed/Unsigned** | Converting between signed and unsigned types.                            | Signed $\to$ Unsigned: Negative values wrap around. Unsigned $\to$ Signed: Behavior is implementation-defined, but often uses the sign bit (danger of sign-flipping). |

### üîë Advanced Type Casting: Pointers

Casting pointers is an advanced technique, often used in system programming, memory management, and low-level I/O.

1.  **`void *` Casting (General Pointers):** The `void *` type is a generic pointer that can hold the address of _any_ data type. Standard library functions like `malloc()` return `void *`.

    ```c
    // Allocation returns void*, must be cast to the desired type
    int *int_ptr = (int *)malloc(sizeof(int));

    // Casting back to void * is implicit and fine
    void *generic_ptr = int_ptr;
    ```

2.  **Pointer-to-Pointer Casting:** Used when you need to access raw memory or reinterpret data structures. This is a common pattern in device drivers or network programming.

    ```c
    // Meaningful Snippet: Pointer Casting
    int x = 0x12345678;

    // Cast an int pointer to a char pointer to read individual bytes
    unsigned char *byte_ptr = (unsigned char *)&x;

    printf("First byte: 0x%x\n", byte_ptr[0]); // Prints '78' or '12' depending on endianness
    ```

3.  **Function Pointer Casting:** Used to cast a function pointer to another function pointer type, typically to create generic callbacks or interface with foreign code (e.g., dynamic libraries).

    ‚ö†Ô∏è **Warning:** Casting between pointer types is generally an indication that the underlying architecture of data is being assumed. This can lead to non-portable or fragile code.

---

## üß© Aggregated Types: Struct, Union, Enum

### üß± Struct (`struct`)

A **structure** (`struct`) is a user-defined data type that aggregates logically related variables (members) of potentially **different** data types under a single name. All members of a struct are stored in **separate memory locations**.

#### üìù Definition and Usage

```c
// Meaningful Snippet: Struct
struct Point {
    int x;
    int y;
}; // Don't forget the semicolon!

// Usage
struct Point p1;
p1.x = 10;
p1.y = 20;

struct Point p2 = {5, 15}; // Initializer list
```

#### üíæ Memory Layout (Padding)

The compiler often inserts **padding** (unused bytes) between members to align them on memory boundaries, which improves access speed. `sizeof(struct)` is often greater than the sum of the sizes of its members.

### ‚öõÔ∏è Union (`union`)

A **union** is a user-defined data type that can hold members of potentially different data types, but **only one member can hold a value at any given time**. All members share the **same memory location**. The size of a union is equal to the size of its largest member.

#### üìù Definition and Usage

```c
// Meaningful Snippet: Union
union Value {
    int i;
    float f;
    char s[20];
};

union Value v;
v.i = 42;             // i is set
// v.f is now garbage/undefined
printf("Int: %d\n", v.i);

v.f = 3.14;           // f is set, overwrites the memory used by i
// v.i is now a reinterpretation of 3.14 as an int
printf("Float: %f\n", v.f);
```

### üè∑Ô∏è Enumeration (`enum`)

An **enumeration** (`enum`) is a list of named integer constants. It makes code more readable by assigning meaningful names to integer values. By default, the first enumerator has the value 0, and subsequent enumerators have a value 1 greater than the previous one.

#### üìù Definition and Usage

```c
// Meaningful Snippet: Enum
enum Day {
    MON = 1, // Explicitly start at 1
    TUE,     // Automatically 2
    WED,     // Automatically 3
    THU,
    FRI,
    SAT,
    SUN
};

enum Day today = WED;

if (today >= SAT) {
    printf("It's the weekend!\n");
}
```

---

## ‚úçÔ∏è Typedef Struct (Aliasing)

The `typedef` keyword is used to create an **alias** (a new name) for an existing data type. It is most frequently used with structures, unions, and enumerations to simplify declarations.

### ‚ùå Without `typedef`

When defining a variable of a structure type, you must include the `struct` keyword every time.

```c
struct Person {
    char name[50];
    int age;
};

// Must use 'struct Person' for variable declaration
struct Person student;
```

### ‚úÖ With `typedef`

By using `typedef`, you create a new, simpler name (`Person`) for the entire structure type (`struct Person`).

```c
// Meaningful Snippet: Typedef Struct
typedef struct {
    char name[50];
    int age;
} Person; // The new type name is 'Person'

// Usage is cleaner, without the 'struct' keyword
Person student;
student.age = 25;
```

#### üîó Self-Referential Structures

When a structure needs to reference itself (e.g., for linked lists or trees), you still need the internal `struct` tag to define the pointer within the structure.

```c
typedef struct Node {
    int data;
    struct Node *next; // Must use 'struct Node' here
} Node; // The user-facing type is 'Node'
```

---

## üéØ Function Pointers

A **function pointer** is a variable that stores the memory address of a function. This allows functions to be passed as arguments to other functions, stored in arrays, or returned from functions, enabling highly flexible and dynamic programming patterns (like callbacks or dispatch tables).

### üìù Declaration Syntax

The syntax can be complex, but it logically replaces the function name with `(*pointer_name)`.

```c
// A function that adds two integers
int add(int a, int b) { return a + b; }

// Meaningful Snippet: Function Pointer Declaration
// Syntax: return_type (*pointer_name)(parameter_types)
int (*operation)(int, int);

// Assignment
operation = add;

// Invocation
int result = operation(5, 3); // result is 8
// OR:
int result_alt = (*operation)(5, 3);
```

### üìû Callbacks

Function pointers are the core mechanism for **callback functions**, where one function calls a function provided by the caller.

```c
// Meaningful Snippet: Function Pointer (Callback)
// Function that accepts a function pointer as an argument
void perform_operation(int x, int y, int (*func)(int, int)) {
    int result = func(x, y);
    printf("Result: %d\n", result);
}

// Example usage
perform_operation(10, 5, add); // Pass the 'add' function address
```

---

## ‚öôÔ∏è Inline Assembly

**Inline assembly** allows embedding Assembly language instructions directly within C source code. This is an advanced, platform-specific technique used for **optimization** or accessing features only available via CPU instructions (e.g., specific memory barriers, atomic operations).

### üêß GCC/Clang Syntax (GNU Assembler Format)

The primary syntax used by GCC and Clang is the `asm` or `__asm__` keyword, followed by the specific assembly instructions and constraints.

```c
// Meaningful Snippet: Basic Inline Assembly (x86/x64)
int a = 10, b = 20, sum;

// 'a' and 'b' are input, 'sum' is output
__asm__ (
    "addl %1, %0" // Add operand 1 to operand 0
    : "=r" (sum)  // Output: sum is stored in a general-purpose register ('r')
    : "r" (a), "r" (b) // Inputs: a and b are loaded into registers
);
// The compiler translates this roughly to: sum = a + b, but at the instruction level
```

#### üõ†Ô∏è Structure of `__asm__`

```c
__asm__ (
    "assembly template"
    : output_operands      // Optional: Variables to be updated by assembly
    : input_operands       // Optional: Variables used as input
    : clobbers             // Optional: List of registers modified by the assembly
);
```

| Component    | Description                                                                                                                                                         |
| :----------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **Template** | A string containing the actual assembly instructions, with placeholders (`%0`, `%1`, etc.) for operands.                                                            |
| **Output**   | Specifies output variables and the constraints (e.g., `"=r"` means output into a register).                                                                         |
| **Input**    | Specifies input variables and their constraints.                                                                                                                    |
| **Clobbers** | Informs the compiler which registers or memory locations the assembly block modifies that are _not_ explicitly listed as outputs (e.g., the stack pointer, memory). |

---

## üü¢ Process Creation and Management with Syscalls

In POSIX-compliant operating systems (like Linux), processes are managed through a set of fundamental **system calls**.

| Syscall                | Purpose                                                                                                     |
| :--------------------- | :---------------------------------------------------------------------------------------------------------- |
| `fork()`               | Creates a new process (the **child**) that is an almost exact copy of the calling process (the **parent**). |
| `exec()` family        | Replaces the current process's memory space with a new program.                                             |
| `exit()`               | Terminates the calling process.                                                                             |
| `wait()` / `waitpid()` | Suspends the calling process until one of its children terminates.                                          |
| `clone()`              | Linux-specific syscall for creating processes or threads with fine-grained control over resource sharing.   |

### üå≥ `fork()`

The primary way to create a new process. When `fork()` is called, it returns:

- **Positive value (Child PID):** To the **parent** process.
- **`0`:** To the **child** process.
- **`-1`:** If an error occurred.

<!-- end list -->

```c
// Meaningful Snippet: fork()
#include <unistd.h>
#include <sys/types.h>

pid_t pid = fork();

if (pid == 0) {
    // This code runs in the CHILD process
    printf("Child process (PID: %d) is running.\n", getpid());
} else if (pid > 0) {
    // This code runs in the PARENT process
    printf("Parent process (PID: %d) created child %d.\n", getpid(), pid);
} else {
    // fork() failed
    perror("fork failed");
}
```

### üöÄ `exec()` Family

The `exec` system calls (e.g., `execlp`, `execvp`) replace the entire contents of the calling process's memory (code, data, stack) with a new program. If successful, `exec` **never returns** to the calling code.

```c
// Meaningful Snippet: execvp()
// Typically called inside the child process after a fork()
char *args[] = {"/bin/ls", "-l", NULL}; // Program path and arguments

// Replaces the current process with 'ls -l'
execvp(args[0], args);

// Only executes if execvp fails
perror("execvp failed");
exit(EXIT_FAILURE);
```

### ‚è≥ `wait()` and `waitpid()`

These calls allow a parent process to **synchronize** with its child, typically waiting for the child to finish and retrieving its **exit status**. This also prevents the child from becoming a **zombie process**.

```c
// Meaningful Snippet: wait()
#include <sys/wait.h>

int status;
pid_t child_pid = fork();

if (child_pid > 0) {
    // Parent waits for any child
    wait(&status);

    if (WIFEXITED(status)) {
        printf("Child exited with status %d\n", WEXITSTATUS(status));
    }
}
```

---

## üö¶ Signals (`signal.h`)

**Signals** are a limited form of inter-process communication (IPC) used to notify a process of an event. They are asynchronous and can interrupt a process's normal execution flow. The primary header for signal handling is `<signal.h>`.

### üö® Common Signals

| Signal    | Default Action      | Description                                                             |
| :-------- | :------------------ | :---------------------------------------------------------------------- |
| `SIGINT`  | Terminate           | Generated when a user presses **Ctrl-C** (interrupt).                   |
| `SIGKILL` | Terminate           | Cannot be caught, blocked, or ignored. **Kills** the process instantly. |
| `SIGSTOP` | Stop                | Cannot be caught or ignored. **Stops** the process (can be resumed).    |
| `SIGTERM` | Terminate           | The **standard request** to terminate (can be caught).                  |
| `SIGSEGV` | Terminate/Core Dump | Invalid memory access (Segmentation fault).                             |
| `SIGCHLD` | Ignore              | Sent to the parent when a child process stops or terminates.            |

### ü§ù Signal Handling with `signal()`

The `signal()` function is the traditional, though less portable/reliable, way to establish a **signal handler**‚Äîa function executed when a specific signal is received.

```c
// Meaningful Snippet: signal()
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

// Signal Handler Function
void sigint_handler(int sig) {
    printf("\nCaught SIGINT (%d). Ignoring interrupt.\n", sig);
    // In a real application, a safe function like write() or exit() should be used here.
}

int main() {
    // Set up the handler for SIGINT (Ctrl+C)
    if (signal(SIGINT, sigint_handler) == SIG_ERR) {
        perror("signal failed");
        return 1;
    }

    printf("Press Ctrl+C to test the signal handler...\n");

    while (1) {
        sleep(1);
    }
    return 0;
}
```

### üöß Blocking Signals (Advanced)

For robust and advanced signal handling, especially in multithreaded applications, the functions in `<sigaction.h>` (like `sigaction()`, `sigprocmask()`) are preferred over `signal()`. They allow signals to be **blocked** during critical sections of code and provide more control over the signal handler's execution context.

```c
// Sending a signal to another process (or itself)
// kill(pid, SIGTERM);
```
